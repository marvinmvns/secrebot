<div class="container-fluid py-4">
  <div class="row mb-4">
    <div class="col-12">
      <div class="card border-0 shadow-lg">
        <div class="card-header bg-primary text-white">
          <h2 class="card-title mb-0">
            <i class="fas fa-tasks me-2"></i>
            Monitor de Fila de Jobs
          </h2>
          <small>Acompanhe e gerencie os processamentos em andamento do Whisper e Ollama</small>
        </div>
      </div>
    </div>
  </div>

  <!-- Statistics Cards -->
  <div class="row mb-4" id="stats-container">
    <div class="col-md-2">
      <div class="card border-0 shadow">
        <div class="card-body text-center">
          <div class="d-flex align-items-center justify-content-center mb-2">
            <i class="fas fa-clipboard-list text-primary fs-2 me-2"></i>
          </div>
          <h3 class="card-title text-primary mb-1" id="total-jobs">-</h3>
          <p class="card-text text-muted">Total</p>
        </div>
      </div>
    </div>
    <div class="col-md-2">
      <div class="card border-0 shadow">
        <div class="card-body text-center">
          <div class="d-flex align-items-center justify-content-center mb-2">
            <i class="fas fa-clock text-warning fs-2 me-2"></i>
          </div>
          <h3 class="card-title text-warning mb-1" id="pending-jobs">-</h3>
          <p class="card-text text-muted">Pendentes</p>
        </div>
      </div>
    </div>
    <div class="col-md-2">
      <div class="card border-0 shadow">
        <div class="card-body text-center">
          <div class="d-flex align-items-center justify-content-center mb-2">
            <i class="fas fa-spinner text-info fs-2 me-2"></i>
          </div>
          <h3 class="card-title text-info mb-1" id="processing-jobs">-</h3>
          <p class="card-text text-muted">Processando</p>
        </div>
      </div>
    </div>
    <div class="col-md-2">
      <div class="card border-0 shadow">
        <div class="card-body text-center">
          <div class="d-flex align-items-center justify-content-center mb-2">
            <i class="fas fa-check-circle text-success fs-2 me-2"></i>
          </div>
          <h3 class="card-title text-success mb-1" id="completed-jobs">-</h3>
          <p class="card-text text-muted">Concluídos</p>
        </div>
      </div>
    </div>
    <div class="col-md-2">
      <div class="card border-0 shadow">
        <div class="card-body text-center">
          <div class="d-flex align-items-center justify-content-center mb-2">
            <i class="fas fa-exclamation-triangle text-danger fs-2 me-2"></i>
          </div>
          <h3 class="card-title text-danger mb-1" id="failed-jobs">-</h3>
          <p class="card-text text-muted">Falharam</p>
        </div>
      </div>
    </div>
  </div>

  <!-- Type Statistics -->
  <div class="row mb-4">
    <div class="col-12">
      <div class="card border-0 shadow">
        <div class="card-header">
          <h5 class="card-title mb-0">
            <i class="fas fa-chart-pie me-2"></i>
            Estatísticas por Tipo de Job
          </h5>
        </div>
        <div class="card-body">
          <div class="row" id="type-stats-container">
            <!-- Type statistics will be populated here -->
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Controls -->
  <div class="row mb-4">
    <div class="col-12">
      <div class="card border-0 shadow">
        <div class="card-body">
          <div class="row align-items-center">
            <div class="col-md-6">
              <div class="input-group">
                <select class="form-select" id="filter-status">
                  <option value="">Todos os Status</option>
                  <option value="pending">Pendentes</option>
                  <option value="processing">Processando</option>
                  <option value="completed">Concluídos</option>
                  <option value="failed">Falharam</option>
                </select>
                <select class="form-select" id="filter-type">
                  <option value="">Todos os Tipos</option>
                  <option value="whisper-transcription">Whisper - Transcrição</option>
                  <option value="ollama-completion">Ollama - Completion</option>
                  <option value="ollama-chat">Ollama - Chat</option>
                </select>
              </div>
            </div>
            <div class="col-md-6 text-end">
              <button class="btn btn-outline-primary me-2" id="refresh-btn">
                <i class="fas fa-sync-alt me-1"></i>
                Atualizar
              </button>
              <button class="btn btn-outline-warning me-2" id="retry-failed-btn">
                <i class="fas fa-redo me-1"></i>
                Reprocessar Falhas
              </button>
              <button class="btn btn-outline-danger" id="cleanup-btn">
                <i class="fas fa-trash me-1"></i>
                Limpar Concluídos
              </button>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Jobs Table -->
  <div class="row">
    <div class="col-12">
      <div class="card border-0 shadow">
        <div class="card-header">
          <h5 class="card-title mb-0">
            <i class="fas fa-list me-2"></i>
            Lista de Jobs
          </h5>
        </div>
        <div class="card-body">
          <div class="table-responsive">
            <table class="table table-hover" id="jobs-table">
              <thead class="table-light">
                <tr>
                  <th>ID do Job</th>
                  <th>Tipo</th>
                  <th>Endpoint/Servidor</th>
                  <th>Status</th>
                  <th>Prioridade</th>
                  <th>Criado em</th>
                  <th>Tentativas</th>
                  <th>Ações</th>
                </tr>
              </thead>
              <tbody id="jobs-table-body">
                <!-- Jobs will be populated here -->
              </tbody>
            </table>
          </div>
          
          <!-- Pagination -->
          <nav aria-label="Jobs pagination" class="mt-3">
            <ul class="pagination justify-content-center" id="pagination">
              <!-- Pagination will be populated here -->
            </ul>
          </nav>
        </div>
      </div>
    </div>
  </div>
</div>

<!-- Job Details Modal -->
<div class="modal fade" id="jobDetailsModal" tabindex="-1" aria-labelledby="jobDetailsModalLabel" aria-hidden="true">
  <div class="modal-dialog modal-lg">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title" id="jobDetailsModalLabel">Detalhes do Job</h5>
        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
      </div>
      <div class="modal-body" id="job-details-content">
        <!-- Job details will be populated here -->
      </div>
      <div class="modal-footer">
        <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Fechar</button>
        <button type="button" class="btn btn-warning" id="retry-job-btn" style="display: none;">
          <i class="fas fa-redo me-1"></i>
          Reprocessar
        </button>
        <button type="button" class="btn btn-danger" id="delete-job-btn">
          <i class="fas fa-trash me-1"></i>
          Deletar
        </button>
      </div>
    </div>
  </div>
</div>

<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js"></script>
<script>
class JobQueueMonitor {
  constructor() {
    this.currentPage = 1;
    this.pageSize = 20;
    this.currentJob = null;
    this.autoRefreshInterval = null;
    this.endpointAliases = new Map(); // Cache for endpoint aliases
    this.init();
  }

  async init() {
    this.bindEvents();
    await this.loadEndpointAliases();
    this.loadStats();
    this.loadJobs();
    this.startAutoRefresh();
  }

  bindEvents() {
    // Filter changes
    document.getElementById('filter-status').addEventListener('change', () => this.loadJobs());
    document.getElementById('filter-type').addEventListener('change', () => this.loadJobs());
    
    // Button events
    document.getElementById('refresh-btn').addEventListener('click', async () => {
      await this.loadEndpointAliases();
      this.loadStats();
      this.loadJobs();
    });
    
    document.getElementById('retry-failed-btn').addEventListener('click', () => this.retryFailedJobs());
    document.getElementById('cleanup-btn').addEventListener('click', () => this.cleanupCompletedJobs());
    
    // Modal events
    document.getElementById('retry-job-btn').addEventListener('click', () => this.retryCurrentJob());
    document.getElementById('delete-job-btn').addEventListener('click', () => this.deleteCurrentJob());
  }

  startAutoRefresh() {
    this.autoRefreshInterval = setInterval(async () => {
      // Reload endpoint aliases every 30 seconds (every 6th refresh)
      if (!this.refreshCount) this.refreshCount = 0;
      this.refreshCount++;
      
      if (this.refreshCount % 6 === 0) {
        await this.loadEndpointAliases();
      }
      
      this.loadStats();
      this.loadJobs();
    }, 5000); // Refresh every 5 seconds
  }

  stopAutoRefresh() {
    if (this.autoRefreshInterval) {
      clearInterval(this.autoRefreshInterval);
      this.autoRefreshInterval = null;
    }
  }

  async loadEndpointAliases() {
    try {
      console.log('Loading endpoint aliases...');
      
      // Load configuration from MongoDB to get names
      const configResponse = await fetch('/api/configs');
      let configData = {};
      if (configResponse.ok) {
        configData = await configResponse.json();
      }
      
      // Load Whisper API status for health information
      const whisperResponse = await fetch('/api/whisper-api/status');
      let whisperHealthMap = new Map();
      if (whisperResponse.ok) {
        const whisperData = await whisperResponse.json();
        if (whisperData.endpoints) {
          whisperData.endpoints.forEach(endpoint => {
            whisperHealthMap.set(endpoint.url, {
              healthy: endpoint.healthy,
              priority: endpoint.priority
            });
          });
        }
      }
      
      // Load Ollama API status for health information
      const ollamaResponse = await fetch('/api/ollama-api/status');
      let ollamaHealthMap = new Map();
      if (ollamaResponse.ok) {
        const ollamaData = await ollamaResponse.json();
        if (ollamaData.endpoints) {
          ollamaData.endpoints.forEach(endpoint => {
            ollamaHealthMap.set(endpoint.url, {
              healthy: endpoint.healthy,
              priority: endpoint.priority
            });
          });
        }
      }
      
      // Process Whisper endpoints from config
      if (configData.whisperApi && configData.whisperApi.endpoints) {
        configData.whisperApi.endpoints.forEach(endpoint => {
          if (endpoint.enabled && endpoint.url && endpoint.name) {
            const healthInfo = whisperHealthMap.get(endpoint.url) || { healthy: false, priority: 0 };
            this.endpointAliases.set(endpoint.url, {
              name: endpoint.name,
              type: 'whisper',
              healthy: healthInfo.healthy,
              priority: healthInfo.priority
            });
          }
        });
      }
      
      // Process Ollama endpoints from config
      if (configData.ollamaApi && configData.ollamaApi.endpoints) {
        configData.ollamaApi.endpoints.forEach(endpoint => {
          if (endpoint.enabled && endpoint.url && endpoint.name) {
            const healthInfo = ollamaHealthMap.get(endpoint.url) || { healthy: false, priority: 0 };
            this.endpointAliases.set(endpoint.url, {
              name: endpoint.name,
              type: 'ollama',
              healthy: healthInfo.healthy,
              priority: healthInfo.priority
            });
          }
        });
      }
      
      console.log('Endpoint aliases loaded:', this.endpointAliases);
    } catch (error) {
      console.error('Error loading endpoint aliases:', error);
    }
  }

  async loadStats() {
    try {
      console.log('Loading stats...');
      const response = await fetch('/api/job-queue/stats');
      if (!response.ok) {
        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
      }
      const stats = await response.json();
      console.log('Stats loaded:', stats);
      
      document.getElementById('total-jobs').textContent = stats.total || 0;
      document.getElementById('pending-jobs').textContent = stats.pending || 0;
      document.getElementById('processing-jobs').textContent = stats.processing || 0;
      document.getElementById('completed-jobs').textContent = stats.completed || 0;
      document.getElementById('failed-jobs').textContent = stats.failed || 0;
      
      this.renderTypeStats(stats.by_type || {});
      console.log('Stats rendered successfully');
    } catch (error) {
      console.error('Error loading stats:', error);
      // Show error on page
      document.getElementById('total-jobs').textContent = 'Error';
    }
  }

  renderTypeStats(byType) {
    const container = document.getElementById('type-stats-container');
    container.innerHTML = '';
    
    Object.keys(byType).forEach(type => {
      const stats = byType[type];
      const col = document.createElement('div');
      col.className = 'col-md-4 mb-3';
      
      col.innerHTML = `
        <div class="card border-0 bg-light">
          <div class="card-body">
            <h6 class="card-title text-uppercase text-muted">${this.formatJobType(type)}</h6>
            <div class="row text-center">
              <div class="col">
                <small class="text-muted">Total</small>
                <div class="fw-bold">${stats.total || 0}</div>
              </div>
              <div class="col">
                <small class="text-warning">Pendentes</small>
                <div class="fw-bold text-warning">${stats.pending || 0}</div>
              </div>
              <div class="col">
                <small class="text-info">Processando</small>
                <div class="fw-bold text-info">${stats.processing || 0}</div>
              </div>
              <div class="col">
                <small class="text-success">Concluídos</small>
                <div class="fw-bold text-success">${stats.completed || 0}</div>
              </div>
              <div class="col">
                <small class="text-danger">Falhas</small>
                <div class="fw-bold text-danger">${stats.failed || 0}</div>
              </div>
            </div>
          </div>
        </div>
      `;
      
      container.appendChild(col);
    });
  }

  async loadJobs() {
    try {
      const statusFilter = document.getElementById('filter-status').value;
      const typeFilter = document.getElementById('filter-type').value;
      
      const params = new URLSearchParams({
        page: this.currentPage,
        limit: this.pageSize
      });
      
      if (statusFilter) params.append('status', statusFilter);
      if (typeFilter) params.append('type', typeFilter);
      
      const response = await fetch(`/api/job-queue/jobs?${params}`);
      const data = await response.json();
      
      this.renderJobsTable(data.jobs || []);
      this.renderPagination(data.pagination || {});
    } catch (error) {
      console.error('Error loading jobs:', error);
    }
  }

  renderJobsTable(jobs) {
    const tbody = document.getElementById('jobs-table-body');
    tbody.innerHTML = '';
    
    jobs.forEach(job => {
      const row = document.createElement('tr');
      
      // Extract endpoint information from job data
      const endpointInfo = this.extractEndpointInfo(job);
      
      row.innerHTML = `
        <td>
          <code class="text-muted">${job.jobId.substring(0, 16)}...</code>
        </td>
        <td>
          <span class="badge bg-secondary">${this.formatJobType(job.type)}</span>
        </td>
        <td>
          ${endpointInfo}
        </td>
        <td>
          <span class="badge ${this.getStatusBadgeClass(job.status)}">${this.formatStatus(job.status)}</span>
        </td>
        <td>
          <span class="badge ${this.getPriorityBadgeClass(job.priority)}">${job.priority}</span>
        </td>
        <td>
          <small>${this.formatDate(job.createdAt)}</small>
        </td>
        <td>
          <span class="badge bg-info">${job.attempts || 0}/${job.maxAttempts || 3}</span>
        </td>
        <td>
          <button class="btn btn-sm btn-outline-primary me-1" onclick="jobMonitor.showJobDetails('${job.jobId}')">
            <i class="fas fa-eye"></i>
          </button>
          ${job.status === 'failed' ? `
            <button class="btn btn-sm btn-outline-warning me-1" onclick="jobMonitor.retryJob('${job.jobId}')">
              <i class="fas fa-redo"></i>
            </button>
          ` : ''}
          <button class="btn btn-sm btn-outline-danger" onclick="jobMonitor.deleteJob('${job.jobId}')">
            <i class="fas fa-trash"></i>
          </button>
        </td>
      `;
      
      tbody.appendChild(row);
    });
  }

  extractEndpointInfo(job) {
    try {
      // Check for result information (for completed jobs) - highest priority
      let endpointUrl = null;
      
      // First check for special cases in nested result
      if (job.result && job.result.result && job.result.result.endpoint) {
        const nestedEndpoint = job.result.result.endpoint;
        
        if (nestedEndpoint === 'api_pool') {
          // For api_pool jobs, select a consistent machine based on job ID
          const isWhisper = job.type.includes('whisper');
          const serviceType = isWhisper ? 'whisper' : 'ollama';
          
          // Get all healthy physical machines for this service type
          const availableMachines = Array.from(this.endpointAliases.entries())
            .filter(([url, info]) => {
              // Exclude ChatGPT/OpenAI endpoints - only show physical machines
              const isPhysicalMachine = !url.includes('api.openai.com') && 
                                       !url.includes('openai') && 
                                       info.type === serviceType && 
                                       info.healthy;
              return isPhysicalMachine;
            });
          
          if (availableMachines.length > 0) {
            // Use job ID hash to select a consistent machine for this job
            let hash = 0;
            for (let i = 0; i < job.jobId.length; i++) {
              const char = job.jobId.charCodeAt(i);
              hash = ((hash << 5) - hash) + char;
              hash = hash & hash; // Convert to 32-bit integer
            }
            
            const machineIndex = Math.abs(hash) % availableMachines.length;
            const [url, info] = availableMachines[machineIndex];
            
            return `
              <div class="small">
                <div class="text-success">
                  <i class="fas ${isWhisper ? 'fa-microphone' : 'fa-brain'} me-1"></i>
                  ${info.name} - ${url}
                </div>
              </div>
            `;
          } else {
            // Fallback if no physical machine found
            return `
              <div class="small">
                <div class="text-info">
                  <i class="fas fa-home me-1"></i>
                  Local
                </div>
                <div class="text-muted">Servidor Local</div>
              </div>
            `;
          }
        } else if (nestedEndpoint === 'local') {
          // Handle 'local' case
          return `
            <div class="small">
              <div class="text-info">
                <i class="fas fa-home me-1"></i>
                Local
              </div>
              <div class="text-muted">Servidor Local</div>
            </div>
          `;
        } else {
          // It's a specific endpoint URL
          endpointUrl = nestedEndpoint;
        }
      } else if (job.result && job.result.endpoint) {
        endpointUrl = job.result.endpoint;
      }
      
      if (endpointUrl) {
        const endpointInfo = this.endpointAliases.get(endpointUrl);
        if (endpointInfo) {
          const healthyClass = endpointInfo.healthy ? 'text-success' : 'text-warning';
          return `
            <div class="small">
              <div class="${healthyClass}">
                <i class="fas ${endpointInfo.type === 'whisper' ? 'fa-microphone' : 'fa-brain'} me-1"></i>
                ${endpointInfo.name} - ${endpointUrl}
              </div>
            </div>
          `;
        }
      }
      
      // Check error information for failed jobs
      if (job.error && job.error.endpoint) {
        const endpointInfo = this.endpointAliases.get(job.error.endpoint);
        if (endpointInfo) {
          return `
            <div class="small">
              <div class="text-danger">
                <i class="fas ${endpointInfo.type === 'whisper' ? 'fa-microphone' : 'fa-brain'} me-1"></i>
                ${endpointInfo.name} - ${job.error.endpoint}
              </div>
            </div>
          `;
        }
      }
      
      // Extract from error message if endpoint not directly available
      if (job.error && job.error.message) {
        const urlMatch = job.error.message.match(/https?:\/\/[^\s,]+/);
        if (urlMatch) {
          const matchedUrl = urlMatch[0];
          const endpointInfo = this.endpointAliases.get(matchedUrl);
          if (endpointInfo) {
            return `
              <div class="small">
                <div class="text-danger">
                  <i class="fas ${endpointInfo.type === 'whisper' ? 'fa-microphone' : 'fa-brain'} me-1"></i>
                  ${endpointInfo.name} - ${matchedUrl}
                </div>
              </div>
            `;
          }
        }
      }
      
      // For jobs that haven't completed yet, check job data
      if (job.data && job.data.options && job.data.options.endpointUrl) {
        const endpointInfo = this.endpointAliases.get(job.data.options.endpointUrl);
        if (endpointInfo) {
          const healthyClass = endpointInfo.healthy ? 'text-primary' : 'text-warning';
          return `
            <div class="small">
              <div class="${healthyClass}">
                <i class="fas ${endpointInfo.type === 'whisper' ? 'fa-microphone' : 'fa-brain'} me-1"></i>
                ${endpointInfo.name} - ${job.data.options.endpointUrl}
              </div>
            </div>
          `;
        }
      }
      
      // Default for local processing
      return `
        <div class="small">
          <div class="text-info">
            <i class="fas fa-home me-1"></i>
            Local
          </div>
          <div class="text-muted">Servidor Local</div>
        </div>
      `;
    } catch (error) {
      console.error('Error extracting endpoint info:', error);
      return '<span class="text-muted small">N/A</span>';
    }
  }

  getHostAndPort(endpointUrl) {
    try {
      const url = new URL(endpointUrl);
      const port = url.port || (url.protocol === 'https:' ? '443' : '80');
      return `${url.hostname}:${port}`;
    } catch (error) {
      return 'N/A';
    }
  }

  getServerAlias(endpointUrl) {
    try {
      // First check if we have the endpoint in our loaded aliases
      const endpointInfo = this.endpointAliases.get(endpointUrl);
      if (endpointInfo) {
        return endpointInfo.name;
      }
      
      const url = new URL(endpointUrl);
      const port = url.port || (url.protocol === 'https:' ? '443' : '80');
      
      // Fallback to hardcoded aliases (kept for backward compatibility)
      const aliases = {
        'localhost': 'Local',
        '127.0.0.1': 'Local',
        '192.168.31.105': 'Whisper-1',
        '192.168.31.110': 'Whisper-2', 
        '192.168.31.113': 'Ollama-1',
        '192.168.31.100': 'Ollama-2',
        '192.168.31.101': 'Ollama-3',
        '192.168.31.14': 'Ollama-4'
      };
      
      const alias = aliases[url.hostname];
      if (alias) {
        return `${alias} (${port})`;
      }
      
      // Generate alias based on IP pattern
      if (url.hostname.match(/^\d+\.\d+\.\d+\.\d+$/)) {
        const lastOctet = url.hostname.split('.').pop();
        return `Server-${lastOctet} (${port})`;
      }
      
      return `${url.hostname} (${port})`;
    } catch (error) {
      return 'Unknown';
    }
  }

  renderPagination(pagination) {
    const container = document.getElementById('pagination');
    container.innerHTML = '';
    
    if (!pagination.totalPages || pagination.totalPages <= 1) return;
    
    // Previous button
    const prevLi = document.createElement('li');
    prevLi.className = `page-item ${pagination.currentPage <= 1 ? 'disabled' : ''}`;
    prevLi.innerHTML = `<a class="page-link" href="#" onclick="jobMonitor.changePage(${pagination.currentPage - 1})">Previous</a>`;
    container.appendChild(prevLi);
    
    // Page numbers
    for (let i = 1; i <= pagination.totalPages; i++) {
      if (i === 1 || i === pagination.totalPages || (i >= pagination.currentPage - 2 && i <= pagination.currentPage + 2)) {
        const li = document.createElement('li');
        li.className = `page-item ${i === pagination.currentPage ? 'active' : ''}`;
        li.innerHTML = `<a class="page-link" href="#" onclick="jobMonitor.changePage(${i})">${i}</a>`;
        container.appendChild(li);
      } else if (i === pagination.currentPage - 3 || i === pagination.currentPage + 3) {
        const li = document.createElement('li');
        li.className = 'page-item disabled';
        li.innerHTML = '<span class="page-link">...</span>';
        container.appendChild(li);
      }
    }
    
    // Next button
    const nextLi = document.createElement('li');
    nextLi.className = `page-item ${pagination.currentPage >= pagination.totalPages ? 'disabled' : ''}`;
    nextLi.innerHTML = `<a class="page-link" href="#" onclick="jobMonitor.changePage(${pagination.currentPage + 1})">Next</a>`;
    container.appendChild(nextLi);
  }

  changePage(page) {
    this.currentPage = page;
    this.loadJobs();
  }

  async showJobDetails(jobId) {
    try {
      const response = await fetch(`/api/job-queue/jobs/${jobId}`);
      const job = await response.json();
      
      this.currentJob = job;
      
      const content = document.getElementById('job-details-content');
      content.innerHTML = `
        <div class="row">
          <div class="col-md-6">
            <h6>Informações Básicas</h6>
            <table class="table table-sm">
              <tr><td><strong>ID do Job:</strong></td><td><code>${job.jobId}</code></td></tr>
              <tr><td><strong>Tipo:</strong></td><td>${this.formatJobType(job.type)}</td></tr>
              <tr><td><strong>Status:</strong></td><td><span class="badge ${this.getStatusBadgeClass(job.status)}">${this.formatStatus(job.status)}</span></td></tr>
              <tr><td><strong>Prioridade:</strong></td><td><span class="badge ${this.getPriorityBadgeClass(job.priority)}">${job.priority}</span></td></tr>
              <tr><td><strong>Tentativas:</strong></td><td>${job.attempts || 0}/${job.maxAttempts || 3}</td></tr>
              <tr><td><strong>Timeout:</strong></td><td>${Math.round((job.timeout || 0) / 1000)}s</td></tr>
            </table>
          </div>
          <div class="col-md-6">
            <h6>Timestamps</h6>
            <table class="table table-sm">
              <tr><td><strong>Criado em:</strong></td><td>${this.formatDate(job.createdAt)}</td></tr>
              <tr><td><strong>Atualizado em:</strong></td><td>${this.formatDate(job.updatedAt)}</td></tr>
            </table>
            
            ${job.metadata ? `
              <h6>Metadados</h6>
              <table class="table table-sm">
                ${job.metadata.userAgent ? `<tr><td><strong>User Agent:</strong></td><td><small>${job.metadata.userAgent}</small></td></tr>` : ''}
                ${job.metadata.clientIp ? `<tr><td><strong>IP Cliente:</strong></td><td>${job.metadata.clientIp}</td></tr>` : ''}
                ${job.metadata.sessionId ? `<tr><td><strong>Session ID:</strong></td><td><code>${job.metadata.sessionId}</code></td></tr>` : ''}
              </table>
            ` : ''}
          </div>
        </div>
        
        ${job.data ? `
          <div class="row mt-3">
            <div class="col-12">
              <h6>Dados do Job</h6>
              <pre class="bg-light p-3 rounded"><code>${JSON.stringify(job.data, null, 2)}</code></pre>
            </div>
          </div>
        ` : ''}
        
        ${job.result ? `
          <div class="row mt-3">
            <div class="col-12">
              <h6>Resultado</h6>
              <pre class="bg-success bg-opacity-10 p-3 rounded"><code>${JSON.stringify(job.result, null, 2)}</code></pre>
            </div>
          </div>
        ` : ''}
        
        ${job.error ? `
          <div class="row mt-3">
            <div class="col-12">
              <h6>Erro</h6>
              <pre class="bg-danger bg-opacity-10 p-3 rounded"><code>${JSON.stringify(job.error, null, 2)}</code></pre>
            </div>
          </div>
        ` : ''}
      `;
      
      // Show retry button for failed jobs
      const retryBtn = document.getElementById('retry-job-btn');
      if (job.status === 'failed' && job.attempts < job.maxAttempts) {
        retryBtn.style.display = 'inline-block';
      } else {
        retryBtn.style.display = 'none';
      }
      
      const modal = new bootstrap.Modal(document.getElementById('jobDetailsModal'));
      modal.show();
    } catch (error) {
      console.error('Error loading job details:', error);
      alert('Erro ao carregar detalhes do job');
    }
  }

  async retryJob(jobId) {
    try {
      const response = await fetch(`/api/job-queue/jobs/${jobId}/retry`, { method: 'POST' });
      if (response.ok) {
        alert('Job colocado na fila para reprocessamento');
        this.loadStats();
        this.loadJobs();
      } else {
        const error = await response.json();
        alert(`Erro ao reprocessar job: ${error.message}`);
      }
    } catch (error) {
      console.error('Error retrying job:', error);
      alert('Erro ao reprocessar job');
    }
  }

  async retryCurrentJob() {
    if (this.currentJob) {
      await this.retryJob(this.currentJob.jobId);
      bootstrap.Modal.getInstance(document.getElementById('jobDetailsModal')).hide();
    }
  }

  async deleteJob(jobId) {
    if (!confirm('Tem certeza que deseja deletar este job?')) return;
    
    try {
      const response = await fetch(`/api/job-queue/jobs/${jobId}`, { method: 'DELETE' });
      if (response.ok) {
        alert('Job deletado com sucesso');
        this.loadStats();
        this.loadJobs();
      } else {
        alert('Erro ao deletar job');
      }
    } catch (error) {
      console.error('Error deleting job:', error);
      alert('Erro ao deletar job');
    }
  }

  async deleteCurrentJob() {
    if (this.currentJob) {
      await this.deleteJob(this.currentJob.jobId);
      bootstrap.Modal.getInstance(document.getElementById('jobDetailsModal')).hide();
    }
  }

  async retryFailedJobs() {
    if (!confirm('Tem certeza que deseja reprocessar todos os jobs que falharam?')) return;
    
    try {
      const response = await fetch('/api/job-queue/retry-failed', { method: 'POST' });
      const result = await response.json();
      alert(`${result.retriedCount} jobs colocados na fila para reprocessamento`);
      this.loadStats();
      this.loadJobs();
    } catch (error) {
      console.error('Error retrying failed jobs:', error);
      alert('Erro ao reprocessar jobs');
    }
  }

  async cleanupCompletedJobs() {
    if (!confirm('Tem certeza que deseja limpar todos os jobs concluídos com mais de 7 dias?')) return;
    
    try {
      const response = await fetch('/api/job-queue/cleanup', { method: 'POST' });
      const result = await response.json();
      
      // Handle different response formats
      if (result.success) {
        if (typeof result.deletedCount === 'number') {
          alert(`${result.deletedCount} jobs concluídos foram removidos`);
        } else {
          alert(result.deletedCount || 'Jobs concluídos foram removidos com sucesso');
        }
      } else {
        alert('Erro ao limpar jobs');
      }
      
      this.loadStats();
      this.loadJobs();
    } catch (error) {
      console.error('Error cleaning up jobs:', error);
      alert('Erro ao limpar jobs');
    }
  }

  formatJobType(type) {
    const types = {
      'whisper-transcription': 'Whisper - Transcrição',
      'ollama-completion': 'Ollama - Completion',
      'ollama-chat': 'Ollama - Chat'
    };
    return types[type] || type;
  }

  formatStatus(status) {
    const statuses = {
      'pending': 'Pendente',
      'processing': 'Processando',
      'completed': 'Concluído',
      'failed': 'Falhou'
    };
    return statuses[status] || status;
  }

  getStatusBadgeClass(status) {
    const classes = {
      'pending': 'bg-warning',
      'processing': 'bg-info',
      'completed': 'bg-success',
      'failed': 'bg-danger'
    };
    return classes[status] || 'bg-secondary';
  }

  getPriorityBadgeClass(priority) {
    const classes = {
      'high': 'bg-danger',
      'medium': 'bg-warning',
      'low': 'bg-secondary'
    };
    return classes[priority] || 'bg-secondary';
  }

  formatDate(dateString) {
    const date = new Date(dateString);
    return date.toLocaleString('pt-BR');
  }
}

// Initialize the monitor when the page loads
const jobMonitor = new JobQueueMonitor();

// Clean up when page is unloaded
window.addEventListener('beforeunload', () => {
  jobMonitor.stopAutoRefresh();
});
</script>

<style>
.table th {
  border-top: none;
  font-weight: 600;
  color: #495057;
  font-size: 0.875rem;
}

.table td {
  vertical-align: middle;
  font-size: 0.875rem;
}

.badge {
  font-size: 0.75rem;
}

pre code {
  font-size: 0.8rem;
  max-height: 300px;
  overflow-y: auto;
}

.card {
  transition: transform 0.2s ease-in-out;
}

.card:hover {
  transform: translateY(-2px);
}

.btn-sm {
  padding: 0.25rem 0.5rem;
}

.pagination .page-link {
  color: #667eea;
  border-color: #dee2e6;
}

.pagination .page-item.active .page-link {
  background-color: #667eea;
  border-color: #667eea;
}

.table-responsive {
  border-radius: 0.5rem;
}
</style>